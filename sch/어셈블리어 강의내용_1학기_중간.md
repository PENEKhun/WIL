      

MMU = 가상주소 -> 실제주소

$VA실제 가상주소 = RVA매핑된 PE 오프셋 + imageBase(가상)$

실제 피지컬 주소 != VA 실제 가상 주소

  

RVA(ImageBase에서 얼마나 떨어져 있는지 offset값)만 있으면 주소에 접근할 수 있음

  

절대 주소가 아닌 ImageBase를 사용하는 이유

이는 PE 파일이 지정된 베이스 위치(ImageBase)를 기준으로 로딩된다는 보장이 없기 때문이다. EXE 파일의 경우 일반적으로 파일이 지정된 위치에 로드된다. DLL의 경우 일반적으로 ImageBase 값이 0x1000000으로 설정되어 있지만 하나의 프로세스에는 여러 개의 DLL이 존재하고 있기 때문에 ImageBase를 기준으로 할 경우 중첩된다. 이러한 중첩을 방지하기 위해 DLL Relocation이 존재하고 있으며 이러한 이유로 인해 절대 주소가 아닌 상대 주소를 사용한다. 만약 ImageBase가 0x2000000이며 RVA 값이 0x1234라고 한다면 가상 주소의 값은 0x02001234이 되는 것이다.

-> PE재배치에 유연하게 대체하기 위함? -> Reloc 섹션에서 수행

  
**IMAGEBASE가 무엇인가** 시험 무조건 나옴.

  

  

image NT 헤더에서

e_magic(매직넘버), e_lfanew 알아둘것

  

**IMAGE_OPTIONAL_HEADER. SizeOfCode의 값은**

**만약 코드 사이즈가 35byte고, fileAligment가 10Bytes(0x0A)면 SizeOfcode는 round up된 40bytes로 정해짐.**

  

IMAGE_OPTIONAL+HEADER. **AddressOfEntryPoint** 는 RVA값이 담긴다.

실제 바이너리가 실행될때 ImageBase + 이 RVA값을 더해 해당 지점에서 실행된다.
  

IP pointer가 가리키는 주소는 .text 코드영역의 주소다

  
.reloc섹션의 기준재배치는 .dll파일을 위한 것

  
COFF에서 현재의 PE구조가 만들어짐
아직까지 COFF의 레거시가 남아있긴하다.
  

fileAlignment가 10이면 

setion들은 10n Bytes…

-   fileAlignment는 섹션을 라운드업

  

sectionalignment는 fileAlignment와 용도는 같으나,

메모리에서 라운드업하기 위해서 필요함

  

근데 Alignment가 왜 필요한거지?

단순 정렬에 편의함때문에???

 

섹션 헤더.**VirutalSize**(PhysicalAdress) 는 섹션의 바이트수인데,  **roundUp되지 않은 바이트 수**이다. 메모리라서 SectionAlignment로 라운드업 되지 않은거임.
섹션 헤더.**VirutalAdress** 는 해당 섹션의 시작 점. 즉 ImageBase로 부터 얼마나 떨어져있나 RVA값이 담겨있음.
섹션 헤더.SizeOfRawData 는 FileAlignment로 roundUp된 **섹션의 바이트수**

그 다음 데이터필드들은 별 중요하지않다.



# 3. IA32 레지스터와 8086 명령어 셋

IA32는 8086의 명령어셋을 포함하고있음.
해당강의는 8086에 한정되어서 진행.

IA32
	- 데이터를 처리하는 기본 유닛의 단위가 32bit
	- 좀 좁게 해석하면 레지스터의 크기
		- x64아키텍쳐면 유닛의 단위, 레지스터의 크기가 64비트라는거임


만약에 32비트 환경에서 eax가 아닌 ax를 쓴다면
| ax | ax |

이런식으로 가상의 16비트 레지스터를 만들어서 구현된다
**레거시 때문**


int *a[10]를 예로,
a는 &a이기 때문에 Base (ESI)이고
10은 &(a+10)이기 때문에 EDI?이다. **이거 확실히 수정**

loop는 ecx에 저장된 값 만큼 루프 실행
만약에 루프 카운터가 10이면, ecx에 10저장

각각의 레지스터는 역할의 용도가 정해져있지만,
실제로는 목적에 안맞게 사용되는 경우가 많음.


| EAX |  | |
|------|------|------|
|EBX      |      |      |


ESI EDI 레지스터는 인덱스 값이 들어감
(배열의 인덱스 같은거)

ESP, EBP는 스택 프레임 관리에 쓰임
EBP = 스택 프레임 시작 주소
ESP = 스택 프레임 마지막 주소

EIP는 다음 실행될 명령어 주소
	(*EIP는 .text(코드 주소)를 가리킨다*)
	(*CS 레지스터 != EIP*)


FLAG는 상태를 저장하는 레지스터

		01111111 => 127
	+ 01111111 => 127
	---------------------	
		11111110 => -1
	
          이것이 sign Flag

mov ax, 10
mov bx, 10
add ax, bx
mov bx, 20
sub ax, bx

이경우 zero flag가 1셋팅됨

Auxiliary carry flag는 별로 안중요한듯

패리티 플래그는 오류검출 플래그.
	연산 결과,
	하위 1바이트에서 1의 갯수가 짝수면 1셋팅



## 산술연산
##### 더하기빼기곱하기 .... 요런것들

CPU는 비트를 계산할때 Signed인지 Unsigned인지 확인을 하고 계산해야함.
	-> Signed이면 MSB를 부호비트로 해석해서 계산해야하고
	--> UnSigned이면 그냥 일반적인 비트계산 하면 됨 
	----> 부호비트가 0이면 양수, 1이면 음수  


	연산에서 Carry 발생 의미 : 최상위 비트(MSB)에서 자리올림(Carry)나 자리내림(Borrow)이 발생하면 CF가 1로 셋팅된다 
	

* **ADD** dest, src
	src오퍼렌드를 더해서 dest에 담아둠
	
	ex) ADD al, 74H -> $al = al + 74H$
	
* **ADC** dest, src
	CF와 함께 src오퍼렌드를 더해서 dest에 담아둠
	
	ex) ADD al, 74H -> $al = al + 74H + CarryFlag$
		
	_**이전 연산에서 Carry가 발생했다면 이것을 더해주라는 의미**_

* **SUB** dest, src
	src오퍼렌드를 빼서 dest에 담아둠
	
	ex) SUB al, 74H -> $al = al - 74H$

* **SBB** dest, src
	CF와 함께 src오퍼렌드를 빼서 dest에 담아둠
	
	ex) SBB al, 74H -> $al = al - 74H - CarrFlag$
		_**이전 연산에서 Carry가 발생했다면 이것을  빼주라는 의미**_


* **MUL** src
	부호없는 곱셈을 연산자
	__Unsigned Data__ 를 처리하기 위한 연산자
	*Signed 연산시엔 사용 불가능*
	
	__특이하게 오퍼랜드를 하나만 가짐__
	( == 곱을 당하는 수는 정해져있다 )
	
	src가 8bits면        ->           $ax = ax \times src$
	src가 16bits면      ->       $dx:ax = ax \times src$
	src가 32bits면     ->   $edx:eax = eax \times src$

	8비트 값 * 8비트 값 = __8비트로 표현불가능__ 
    그래서 16비트 레지스터에 넣음
	이러한 이유로 위와같은 계산 규칙이 만들어짐.

* **IMUL** src
	부호있는 곱셈 연산자
	__signed Data__ 를 처리하기 위한 연산자
	*UnSigned 연산시엔 사용 불가능*
	
	src가 8bits면        ->           $ax = ax \times src$
	src가 16bits면      ->       $dx:ax = ax \times src$
	src가 32bits면     ->   $edx:eax = eax \times src$


* **DIV** src
	부호없는 나눗셈 연산자
	__Unsigned Data__ 를 처리하기 위한 연산자
	*Signed 연산시엔 사용 불가능*

	__특이하게 오퍼랜드를 하나만 가짐
	( == 나눔을 당하는 수는 정해져있다 )
	
	src가 8bits면        ->     몫은 ax, 나머지 ah 저장
	src가 16bits면      ->      몫은 ax, 나머지는 dx 저장
	src가 32bits면     ->   몫은 eax, 나머지는 edx 저장
	
* **IDIV** src
	부호있는 나눗셈 연산자
	__Unsigned Data__ 를 처리하기 위한 연산자
	*Signed 연산시엔 사용 불가능*

	src가 8bits면        ->     몫은 ax, 나머지 ah 저장
	src가 16bits면      ->      몫은 ax, 나머지는 dx 저장
	src가 32bits면     ->   몫은 eax, 나머지는 edx 저장

* **CMP** dest, src
	첫번째 Operand와 두번째 Operand를 뺀다.   
	두 Operand가 같은지 판단 가능
	단지 플래그 값을 세팅하여 분기문에게 영향을 준다 ex) JE, JZ.... 같은 분기문   
	
	Dest > Src면        ->      
	Dest = Src면        ->
	Dest < Src면        ->


## 분기 실행 명령어

* **CALL** dest
	함수 실행할때 쓰는 명령어
	- PUSH eip -> JMP dest
		-다음 실행할 명령어를 기억해두고, 함수 시작

* **RET** 

##### 함수 프롤로그 애필로그
- 프롤로그
	- 스택프레임을 만들어주는 것
	- push ebp (__스택프레임 복구를 위함__)
	- mov ebp, esp
	
- 에필로그
	- 이전 스텍프레임을 복구하고 복귀주소로 점프함
	- leave
		- mov esp, ebp
		- pop ebp
	- ret
		- pop eip
		- jmp eip

스택 프레임의 가용범위
	현 스택 프레임의 처음 - EBP
	현 스택 프레임의 끝 - ESP









